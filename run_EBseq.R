library(EBSeq)

########################################################################
### all 20 samples
### gene level

## read in data matrix generated by 'rsem-generate-data-matrix' and gencode annotations
geneAnnotation <- read.table("gencode.vM10.gene.annotation.txt",sep="\t",header=T)
rownames(geneAnnotation) <- geneAnnotation$geneID
gene.mat <- data.matrix(read.table("allSamples_rsem_genes_results.txt"))
colnames(gene.mat) <- sapply(strsplit(colnames(gene.mat),perl = T, split = "\\." ),"[[",1)

## generate size factors and condition factors
gene.sizes <- MedianNorm(gene.mat)
# use QUantileNorm() If quantile normalization is preferred
# gene.sizes <- QuantileNorm(gene.mat, .75)

## generate condition factors
gene.conditions <- factor(sampleInfo$group)

## generate all possible patterns given the conditions
gene.PosParti <- GetPatterns(gene.conditions)
# subset interested patterns
# gene.PosParti=gene.PosParti[-4,]
PlotPattern(gene.PosParti)

## Run EBMultiTest for multiple comparing
# enable pooling by 'Pool' if comparing samples with no replicates
# Number of iterations is set by 'maxround'; keep in mind to check convergency later
# from version 1.7.1, by default, genes with all 0â€™s will be removed before testing
# (earlier version remove genes with 75th quantile less than 10)
gene.MultiOut <- EBMultiTest(Data = gene.mat, Conditions = gene.conditions, AllParti = gene.PosParti, sizeFactors = gene.sizes, maxround = 10, Qtrm = 1, QtrmCut = 0, Pool = F)

## checking convergence of alpha, beta and p, requiring changes less than 0.001 to declare convergence
# raise 'maxround' if convergence is not reached
gene.MultiOut$Alpha
gene.MultiOut$Beta
gene.MultiOut$P

## Checking the model fit and other diagnostics
par(mfrow=c(2,2))
QQP(gene.MultiOut)
DenNHist(gene.MultiOut)

## generate output
# get posterior probabilities
gene.MultiPP <- GetMultiPP(gene.MultiOut)
# calculate the Fold Change (FC) and Posterior FC
# The posterior FC tends to shrink genes with low expressions (small rank) !!!!
gene.eename <- rownames(gene.PosParti)[which(rowSums(gene.PosParti) == length(levels(gene.conditions)))]
gene.PP <- as.data.frame(gene.MultiPP$PP)
gene.pos <- which(names(gene.PP) == gene.eename)
gene.probs <- rowSums(gene.PP[,-gene.pos])
gene.MultiFC <- GetMultiFC(gene.MultiOut)

gene.results <- cbind(geneAnnotation[rownames(gene.PP),], gene.mat[rownames(gene.PP),], gene.MultiFC$CondMeans, gene.MultiFC$FCMat, gene.MultiFC$PostFCMat, gene.PP, gene.MultiPP$MAP[rownames(gene.PP)], gene.probs)
colnames(gene.results) <- c(colnames(geneAnnotation), paste(colnames(gene.mat),"ExpectedCount",sep="_"), paste(colnames(gene.MultiFC$CondMeans),"normalizedMean",sep="_"), paste(colnames(gene.MultiFC$FCMat),"FC",sep="_"), paste(colnames(gene.MultiFC$PostFCMat),"PostFC",sep="_"), colnames(gene.PP), "MAP", "PPDE")
gene.results <- gene.results[order(-gene.results[,"PPDE"], gene.results[,"MAP"]),]
write.table(gene.results, "allSamples_genes_EBSeq_annotated.txt",quote = F,eol = "\n",sep = "\t",row.names = F,col.names = T)
write.table(gene.MultiPP$Patterns,"allSamples_genes_EBSeq_annotated.pattern",quote = F,eol = "\n",sep = "\t")



########################################################################
### transcript level

transcriptAnnotation <- read.table("gencode.vM9.transcript.annotation.txt",sep="\t",header=T)
rownames(transcriptAnnotation) <- transcriptAnnotation$transcriptID

## generate Ig vector
# 'TrunThre' might need to be tuned if there is evidence that the Ng = 4; 5; 6... groups should be treated as separate groups
#  memory-intensive step!!!! 
### generate at server, save output... ###
# NgList <- GetNg(transcriptAnnotation$transcriptID, transcriptAnnotation$geneID, TrunThre=3)
# write.table(NgList$GeneNg,"gencode.vM9.NgList.GeneNg.txt",sep="\t",eol="\n",quote=F)
# write.table(NgList$GeneNgTrun,"gencode.vM9.NgList.GeneNgTrunBy3.txt",sep="\t",eol="\n",quote=F)
# write.table(NgList$IsoformNg,"gencode.vM9.NgList.IsoformNg.txt",sep="\t",eol="\n",quote=F)
# write.table(NgList$IsoformNgTrun,"gencode.vM9.NgList.IsoformNgTrunBy3.txt",sep="\t",eol="\n",quote=F)

### ...and read in locally ###
IsoNgTrun.temp <- read.table("gencode.vM9.NgList.IsoformNgTrunBy3.txt",sep="\t")
IsoNgTrun <- unlist(IsoNgTrun.temp)
dim(IsoNgTrun) <- dim(IsoNgTrun.temp)[1]
rownames(IsoNgTrun) <- rownames(IsoNgTrun.temp)

transcript.mat <- data.matrix(read.table("allSamples_rsem_isoforms_results.txt"))
transcript.sizes <- MedianNorm(transcript.mat)
transcript.conditions <- factor(c(rep(c("EE_dDG","EE_vDG"),times=5),rep(c("SH_dDG","SH_vDG"),times=5)),levels=unique(c("EE_dDG","EE_vDG","SH_dDG","SH_vDG")))
transcript.PosParti <- GetPatterns(transcript.conditions)

transcript.MultiOut <- EBMultiTest(Data = transcript.mat, NgVector = IsoNgTrun, Conditions = transcript.conditions, AllParti = transcript.PosParti, sizeFactors = transcript.sizes, maxround = 10, Qtrm = 1, QtrmCut = 0, Pool = F)

transcript.MultiOut$Alpha
transcript.MultiOut$Beta
transcript.MultiOut$P

par(mfrow=c(2,2))
QQP(transcript.MultiOut)
DenNHist(transcript.MultiOut)

transcript.MultiPP <- GetMultiPP(transcript.MultiOut)
transcript.eename <- rownames(transcript.PosParti)[which(rowSums(transcript.PosParti) == length(levels(transcript.conditions)))]
transcript.PP <- as.data.frame(transcript.MultiPP$PP)
transcript.pos <- which(names(transcript.PP) == transcript.eename)
transcript.probs <- rowSums(transcript.PP[,-transcript.pos])
transcript.MultiFC <- GetMultiFC(transcript.MultiOut)

transcript.results <- cbind(transcriptAnnotation[rownames(transcript.PP),], transcript.mat[rownames(transcript.PP),], transcript.MultiFC$CondMeans, transcript.MultiFC$FCMat, transcript.MultiFC$PostFCMat, transcript.PP, transcript.MultiPP$MAP[rownames(transcript.PP)], transcript.probs)
colnames(transcript.results) <- c(colnames(transcriptAnnotation), paste(colnames(transcript.mat),"ExpectedCount",sep="_"), paste(colnames(transcript.MultiFC$CondMeans),"normalizedMean",sep="_"), paste(colnames(transcript.MultiFC$FCMat),"FC",sep="_"), paste(colnames(transcript.MultiFC$PostFCMat),"PostFC",sep="_"), colnames(transcript.PP), "MAP", "PPDE")
transcript.results <- transcript.results[order(-transcript.results[,"PPDE"], transcript.results[,"MAP"]),]
write.table(transcript.results, "allSamples_transcripts_EBSeq_annotated.txt",quote = F,eol = "\n",sep = "\t",row.names = F,col.names = T)
write.table(transcript.MultiPP$Patterns,"allSamples_transcripts_EBSeq_annotated.pattern",quote = F,eol = "\n",sep = "\t")
